# DS-Containers/app/streamlit_app.py
import streamlit as st
import polars as pl
import plotly.express as px
import os
from datetime import datetime, timedelta

st.set_page_config(page_title="Restaurant Expense EDA Dashboard", layout="wide")
st.title("ðŸ“Š Restaurant Expense Exploratory Data Analysis")
st.markdown("This dashboard visualizes expense data directly from CSV files in the `data/` directory.")

# --- Data Loading ---
@st.cache_data
def load_data(data_dir="../data"):
    """
    Loads all CSV files from the specified directory into a single Polars DataFrame.
    Assumes CSVs are in the format generated by data_generator.py.
    """
    all_files = [os.path.join(data_dir, f) for f in os.listdir(data_dir) if f.endswith('.csv')]
    
    if not all_files:
        st.warning(f"No CSV files found in '{data_dir}'. Please generate some data first!")
        return pl.DataFrame() # Return empty Polars DataFrame

    df_list = []
    for f in all_files:
        try:
            # Use Polars to read CSV
            df = pl.read_csv(f)
            df_list.append(df)
        except Exception as e:
            st.error(f"Error loading {f}: {e}")
            continue
            
    if not df_list:
        return pl.DataFrame() # Return empty Polars DataFrame

    # Concatenate DataFrames using Polars
    combined_df = pl.concat(df_list, how="vertical")
    
    # Ensure 'date' column is datetime
    # The format string should match the actual format in your CSVs, e.g., "YYYY-MM-DD HH:MM:SS.f"
    combined_df = combined_df.with_columns(
        pl.col('date').str.strptime(pl.Datetime, "%Y-%m-%d %H:%M:%S%.f").alias("date")
    )
    
    # Add time-based features for analysis using Polars expressions
    combined_df = combined_df.with_columns([
        pl.col('date').dt.weekday().alias('day_of_week_num'), # Numeric day of week (Monday=1, Sunday=7)
        pl.col('date').dt.month().alias('month'),
    ])
    
    return combined_df

# Load the data
df = load_data()

# --- NEW: Link to MLflow UI ---
st.markdown("---")
st.markdown("For detailed ML experiment tracking, visit the [MLflow UI](http://localhost:5000).")
st.markdown("---")
# --- END NEW ---

if df.is_empty(): # Check if Polars DataFrame is empty
    st.info("Dashboard cannot be displayed as no data was loaded.")
else:
    # --- NEW: Sidebar Filters ---
    st.sidebar.header("Filter Data")

    # Product Category Filter
    all_products = ["All"] + df['product'].unique().sort().to_list()
    selected_product = st.sidebar.selectbox("Select Product Category", all_products)

    # Supplier Filter
    all_suppliers = ["All"] + df['supplier'].unique().sort().to_list()
    selected_supplier = st.sidebar.selectbox("Select Supplier", all_suppliers)

    # Date Range Filter
    min_date = df['date'].min().date()
    max_date = df['date'].max().date()
    date_range = st.sidebar.date_input("Select Date Range", value=(min_date, max_date), min_value=min_date, max_value=max_date)

    # Apply filters
    filtered_df = df.clone() # Start with a clone to avoid modifying original cached df

    if selected_product != "All":
        filtered_df = filtered_df.filter(pl.col('product') == selected_product)
    
    if selected_supplier != "All":
        filtered_df = filtered_df.filter(pl.col('supplier') == selected_supplier)

    # Ensure date_range has two dates before filtering
    if len(date_range) == 2:
        start_date = datetime.combine(date_range[0], datetime.min.time()) # Convert date to datetime at start of day
        end_date = datetime.combine(date_range[1], datetime.max.time())   # Convert date to datetime at end of day
        filtered_df = filtered_df.filter(
            (pl.col('date') >= start_date) & (pl.col('date') <= end_date)
        )
    elif len(date_range) == 1: # Handle case where only one date is selected (e.g., initial state or user interaction)
        start_date = datetime.combine(date_range[0], datetime.min.time())
        filtered_df = filtered_df.filter(pl.col('date') >= start_date)


    # Check if filtered_df is empty after applying filters
    if filtered_df.is_empty():
        st.warning("No data matches the selected filters. Please adjust your selections.")
        st.stop() # Stop execution if no data to display

    # --- End NEW: Sidebar Filters ---

    st.subheader("Raw Data Preview (Polars DataFrame)")
    st.dataframe(filtered_df.head().to_pandas()) # Display filtered data

    st.subheader("Overall Expense Trends")
    
    # Ensure filtered_df is sorted before group_by_dynamic
    df_sorted_for_trends = filtered_df.sort("date") 

    weekly_summary = df_sorted_for_trends.group_by_dynamic( # Use the sorted filtered DataFrame
        index_column="date",
        every="1w",
        offset="1d"
    ).agg(
        pl.col("total_price").sum().alias("Total Expense")
    ).sort("date")
    
    weekly_summary = weekly_summary.rename({"date": "Week Start"})
    weekly_summary_pd = weekly_summary.to_pandas()
    
    fig_weekly_expense = px.line(
        weekly_summary_pd,
        x='Week Start',
        y='Total Expense',
        title='Total Expense Over Time (Filtered)',
        labels={'Week Start': 'Week Start Date', 'Total Expense': 'Total Expense ($)'}
    )
    st.plotly_chart(fig_weekly_expense, use_container_width=True)

    st.subheader("Expense Breakdown")

    col1, col2 = st.columns(2)

    with col1:
        st.write("#### Expense by Product Category")
        product_expense = filtered_df.group_by('product').agg(
            pl.col('total_price').sum().alias('total_price')
        ).sort('total_price', descending=True).to_pandas()
        
        fig_product = px.bar(
            product_expense,
            x='total_price',
            y='product',
            orientation='h',
            title='Total Expense by Product Category (Filtered)',
            labels={'total_price': 'Total Expense ($)', 'product': 'Product Category'}
        )
        st.plotly_chart(fig_product, use_container_width=True)

    with col2:
        st.write("#### Expense by Supplier")
        supplier_expense = filtered_df.group_by('supplier').agg(
            pl.col('total_price').sum().alias('total_price')
        ).sort('total_price', descending=True).to_pandas()
        
        fig_supplier = px.bar(
            supplier_expense,
            x='total_price',
            y='supplier',
            orientation='h',
            title='Total Expense by Supplier (Filtered)',
            labels={'total_price': 'Total Expense ($)', 'supplier': 'Supplier'}
        )
        st.plotly_chart(fig_supplier, use_container_width=True)

    st.write("#### Expense by Payment Method")
    payment_expense = filtered_df.group_by('payment_method').agg(
        pl.col('total_price').sum().alias('total_price')
    ).to_pandas()
    
    fig_payment = px.pie(
        payment_expense,
        values='total_price',
        names='payment_method',
        title='Expense Distribution by Payment Method (Filtered)'
    )
    st.plotly_chart(fig_payment, use_container_width=True)

    st.subheader("Detailed Expense Breakdown Table")
    st.dataframe(filtered_df.sort('date', descending=True).to_pandas())

    st.subheader("Summary Statistics")
    st.dataframe(filtered_df.describe().to_pandas())

    st.subheader("Average Daily Expense")
    daily_avg_sorted_df = filtered_df.sort("date")
    daily_avg = daily_avg_sorted_df.group_by_dynamic(
        index_column="date",
        every="1d"
    ).agg(
        pl.col("total_price").sum().alias("Daily Total")
    ).sort("date")

    daily_avg_pd = daily_avg.to_pandas()

    fig_daily_avg = px.bar(
        daily_avg_pd,
        x='date',
        y='Daily Total',
        title='Daily Total Expense (Filtered)'
    )
    st.plotly_chart(fig_daily_avg, use_container_width=True)
